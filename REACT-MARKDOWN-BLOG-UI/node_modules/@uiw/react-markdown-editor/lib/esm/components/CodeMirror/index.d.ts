import * as CodeMirror from 'codemirror';
import 'codemirror/mode/markdown/markdown';
import { Component } from 'react';
import { DomEvent, IDefineModeOptions, IEventDict, IGetSelectionOptions, IInstance, ISetScrollOptions, ISetSelectionOptions } from '../../common/codemirror';
import { IProps } from '../../common/props';
import './codemirror.less';
import './index.less';
export interface ICodeMirror extends IProps {
    value?: string;
    width?: number | string;
    height?: number | string;
    className?: string;
    cursor?: CodeMirror.Position;
    defineMode?: IDefineModeOptions;
    editorDidConfigure?: (editor: IInstance) => void;
    editorDidMount?: (editor: IInstance, value: string, cb: () => void) => void;
    editorWillMount?: () => void;
    editorWillUnmount?: (lib: any) => void;
    onClear?: (from: CodeMirror.Position, to: CodeMirror.Position) => void;
    onBlur?: DomEvent;
    onChange?: (editor: IInstance, data: CodeMirror.EditorChange, value: string) => void;
    onContextMenu?: DomEvent;
    onCopy?: DomEvent;
    onCursor?: (editor: IInstance, data: CodeMirror.Position) => void;
    onCut?: DomEvent;
    onCursorActivity?: (editor: IInstance) => void;
    onDblClick?: DomEvent;
    onDragEnter?: DomEvent;
    onDragLeave?: DomEvent;
    onDragOver?: DomEvent;
    onDragStart?: DomEvent;
    onDrop?: DomEvent;
    onFocus?: DomEvent;
    onGutterClick?: (editor: IInstance, lineNumber: number, gutter: string, event: Event) => void;
    onKeyDown?: DomEvent;
    onKeyPress?: DomEvent;
    onKeyUp?: DomEvent;
    onMouseDown?: DomEvent;
    onPaste?: DomEvent;
    onRenderLine?: (editor: IInstance, line: CodeMirror.LineHandle, element: HTMLElement) => void;
    onScroll?: (editor: IInstance, data: CodeMirror.ScrollInfo) => void;
    onSelection?: (editor: IInstance, data: IGetSelectionOptions) => void;
    onTouchStart?: DomEvent;
    onUpdate?: (editor: IInstance) => void;
    onViewportChange?: (editor: IInstance, start: number, end: number) => void;
    options?: CodeMirror.EditorConfiguration;
    selection?: {
        ranges: ISetSelectionOptions[];
        focus?: boolean;
    };
    scroll?: ISetScrollOptions;
    [key: string]: any;
}
export interface ICodeMirrorState {
    value: string;
}
export default class ReactCodeMirror extends Component<ICodeMirror, ICodeMirrorState> {
    static defaultProps: ICodeMirror;
    textarea: HTMLTextAreaElement;
    editor: any;
    constructor(props: Readonly<ICodeMirror>);
    render(): JSX.Element;
    componentWillMount(): void;
    componentDidMount(): void;
    UNSAFE_componentWillReceiveProps(nextPros: ICodeMirror): void;
    shouldComponentUpdate(nextProps: ICodeMirror, nextState: ICodeMirrorState): boolean;
    getEventHandleFromProps(): IEventDict;
    private renderCodeMirror;
}
